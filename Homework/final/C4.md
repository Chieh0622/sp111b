# C4-Compiler
## 簡介
C4 是 Robert Swierczek 寫的一個小型 C 語言編譯器，全部 527 行的原始碼都在 c4.c 裏 。

並沒有支援完整的 C 語言語法，只支援了剛好足夠《自我編譯》的那些語法。

C4是把C語言源碼先編譯成其專門設計的字節碼（bytecode），然後直接在虛擬機中解釋執行。

而傳統的C語言編譯器，最終都把C語言源碼編譯成可執行文件，也就是二進位的機器碼。

### compiler 分類
按照生成代碼所運行的系統平台劃分，這個平台稱為目標平台。

* 本地編譯器: 運行於與編譯器所在相同類型的計算機和操作系統之上。
* 交叉編譯器: 輸出可以運行於不同的平台之上的編譯器。
* 嵌入式系統通常沒有軟件開發環境，因此，為這類系統開發軟件時，通常需要使用交叉編譯器

### c4 特色
* Self-Host Compiler.(自舉-自己編譯自己)
* Support three types: INT, CHAR, PTR, pointer to INT or CHAR.
* Support if-else and while.
* Support enum.
* Variable Declarations should NOT be assigned.
* Local Variables Declaration 必須在 Function 裡面的最開頭位置。
* single-pass compiler(僅使每個編譯單元的各個部分通過一次，然後立即將每個部分轉換為其最終機器代碼的編譯器)
* 最後生成虛擬機的代碼。

### 內存
內存用於存儲數據，這裡的數據可以是代碼，也可以是其它的數據。現代操作系統在操作內存時，並不是直接處理”物理內存“，而是操作”虛擬內存“。虛擬內存可以理解為一種映射，它的作用是屏蔽了物理的細節。例如 32 位的機器中，我們可以使用的內存地址為 2^32 = 4G，而電腦上的實際內存可能只有 256 M。操作系統將我們使用的虛擬地址映射到了到實際的內存上。

當然，我們這裡並不需要了解太多，但需要了解的是：進程的內存會被分成幾個段：

text 用於存放代碼（指令）。
data 用於存放初始化了的數據，如int i = 10;，就需要存放到數據段中。
bss 用於存放未初始化的數據，如 int i[1000];，因為不關心其中的真正數值，所以單獨存放可以節省空間，減少程序的體積。
stack 用於處理函數調用相關的數據，如 calling frame 或是函數的局部變量等。
heap 用於為程序動態分配內存。

### 寄存器
計算機中的寄存器用於存放計算機的運行狀態，真正的計算機中有許多不同種類的寄存器，但我們的虛擬機中只使用 4 個寄存器：

* PC 程序計數器，它存放的是一個內存地址，該地址中存放著 下一條 要執行的計算機指令。
* SP 指針寄存器，永遠指向當前的棧頂。注意的是由於棧是位於高地址並向低地址增長的，所以入棧時 SP 的值減小。
* BP 基址指針。也是用於指向棧的某些位置，在調用函數時會使用到它。
* AX 通用寄存器，我們的虛擬機中，它用於存放一條指令執行後的結果。

### MOV
MOV 是所有指令中最基礎的一個，它用於將數據放進寄存器或內存地址，有點類似於 C 語言中的賦值語句。 x86 的 MOV 指令有兩個參數，分別是源地址和目標地址：MOV dest, source ，表示將 source 的內容放在 dest 中，它們可以是一個數、寄存器或是一個內存地址。
一方面，我們的虛擬機只有一個寄存器，另一方面，識別這些參數的類型（是數據還是地址）是比較困難的，因此我們將 MOV 指令拆分成 5 個指令，這些指令只接受一個參數：

* IMM <num> 將 <num> 放入寄存器 ax 中。
* LC 將對應地址中的字符載入 ax 中，要求 ax 中存放地址。
* LI 將對應地址中的整數載入 ax 中，要求 ax 中存放地址。
* SC 將 ax 中的數據作為字符存放入地址中，要求棧頂存放地址。
* SI 將 ax 中的數據作為整數存放入地址中，要求棧頂存放地址。

### 詞法分析器與編譯器
要是深入詞法分析器，你就會發現，它的本質上也是編譯器。我們的編譯器是以標記流為輸入，輸出彙編代碼，而詞法分析器則是以源碼字符串為輸入，輸出標記流。
```
                 +-------+                      +--------+
-- source code --> | lexer | --> token stream --> | parser | --> assembly
                   +-------+                      +--------+
```
  
### 詞法分析器的框架
即 next() 函數的主體：
```
void next() {
    char *last_pos;
    int hash;

    while (token = *src) {
        ++src;
        // parse token here
    }
    return;
}
```
  
### 標識符與符號表
標識符（identifier）可以理解為變量名。對於語法分析而言，我們並不關心一個變量具體叫什麼名字，而只關心這個變量名代表的唯一標識。例如 int a; 定義了變量 a，而之後的語句 a = 10，我們需要知道這兩個 a 指向的是同一個變量。

基於這個理由，詞法分析器會把掃描到的標識符全都保存到一張表中，遇到新的標識符就去查這張表，如果標識符已經存在，就返回它的唯一標識。

那麼我們怎麼表示標識符呢？如下：
```
struct identifier {
    int token;
    int hash;
    char * name;
    int class;
    int type;
    int value;
    int Bclass;
    int Btype;
    int Bvalue;
}
```
1. token：該標識符返回的標記，理論上所有的變量返回的標記都應該是Id，但實際上由於我們還將在符號表中加入關鍵字如if, while 等，它們都有對應的標記。
2. hash：顧名思義，就是這個標識符的哈希值，用於標識符的快速比較。
3. name：存放標識符本身的字符串。
4. class：該標識符的類別，如數字，全局變量或局部變量等。
5. type：標識符的類型，即如果它是個變量，變量是 int 型、char 型還是指針型。
6. value：存放這個標識符的值，如標識符是函數，剛存放函數的地址。
7. BXXXX：C 語言中標識符可以是全局的也可以是局部的，當局部標識符的名字與全局標識符相同時，用作保存全局標識符的信息。
 
## c4-c in 4 functions 虛擬機分析
```
int *pc, *sp, *bp, a, cycle; 
```
* pc 程序計數器/指令指針
* sp 堆棧暫存器,指向暫頂,暫時由高地址向低地址生成
* bp 基址暫存器
* a 累加器
* cycle 執行指令計數
  
## 程式執行
  
  
## 參考資料
[手把手教你构建 C 语言编译器](https://lotabout.me/2016/write-a-C-interpreter-8/)
[C4：4個函數，528行代碼實現可自舉的C語言編譯器](https://kknews.cc/zh-tw/code/zrkmqga.html)
[C in four function (c4) Compiler](https://hackmd.io/@srhuang/Bkk2eY5ES)
https://gitlab.com/ccc110/sp/-/tree/master/04-c4
